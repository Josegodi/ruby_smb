require 'ruby_smb/server/share/provider/virtual_disk/virtual_pathname'
require 'ruby_smb/server/share/provider/virtual_disk/virtual_stat'

module RubySMB
  class Server
    module Share
      module Provider
        class VirtualDisk < Disk
          # A dynamic file is one whose contents are generated by the specified
          # block. The contents must be of a fixed size and will either be
          # truncated or padded to that size.
          class VirtualDynamicFile < VirtualPathname
            # @param [Hash] disk The mapping of paths to objects representing the virtual file system.
            # @param [String] path The path of this entry.
            # @param [Integer] content_size The size in bytes of the file contents.
            # @param [File::Stat] stat An explicit stat object describing the file.
            # @param [String] pad The character to use for padding the contents when necessary.
            def initialize(disk, path, content_size, stat: nil, pad: "\x00")
              stat = stat || VirtualStat.new(file?: true, size: content_size)
              raise ArgumentError.new('stat is not a file') unless stat.file?

              # todo: need to figure something out when the stat.size does not match the content.size

              @content_size = content_size
              @pad = pad
              @generate_content = -> { '' }
              super(disk, path, stat: stat)
            end

            # The content generation routine. When called without a block will generate the file contents. When called
            # with a block will set the generation routine. The contents are returned as is without any
            # size-modifications.
            def generate_content(&block)
              if block.nil?
                @generate_content.call
              else
                @generate_content = block
              end
            end

            def open(mode = 'r', &block)
              content = generate_content
              if content.length < @content_size
                content = content.ljust(@content_size, @pad)
              elsif content.length > @content_size
                content = content[0...@content_size]
              end

              file = StringIO.new(content)
              block_given? ? block.call(file) : file
            end
          end

          # A static file is one whose contents are known at creation time and
          # do not change.
          class VirtualStaticFile < VirtualDynamicFile
            # @param [Hash] disk The mapping of paths to objects representing the virtual file system.
            # @param [String] path The path of this entry.
            # @param [String] content The static content of this file.
            # @param [File::Stat] stat An explicit stat object describing the file.
            def initialize(disk, path, content, stat: nil)
              super(disk, path, content.size)
              generate_content do
                content
              end
            end
          end

          # A mapped file is one who is backed by an entry on disk. The path
          # need not be present, but if it does exist, it must be a file.
          class VirtualMappedFile < VirtualPathname
            # @param [Hash] disk The mapping of paths to objects representing the virtual file system.
            # @param [String] path The path of this entry.
            # @param [String, Pathname] mapped_path The path on the local file system to map into the virtual file system.
            def initialize(disk, path, mapped_path)
              mapped_path = Pathname.new(File.expand_path(mapped_path)) if mapped_path.is_a?(String)
              raise ArgumentError.new('mapped_path must be absolute') unless mapped_path.absolute? # it needs to be absolute so it is independent of the cwd

              @virtual_disk = disk
              @path = path
              @mapped_path = mapped_path
            end

            def exist?
              # filter out anything that's not a directory but allow the file to be missing, this prevents exposing
              # directories which could yield path confusion errors
              @mapped_path.exist? && @mapped_path.file?
            end

            def stat
              @mapped_path.stat
            end

            def open(mode = 'r', &block)
              @mapped_path.open(mode, &block)
            end
          end
        end
      end
    end
  end
end
